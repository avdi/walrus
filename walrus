#!/bin/bash

default_port=8080
declare -A content_types=([js]=text/javascript [html]=text/html)

# Set up a logging system that can route around output redirection
logfd=10                        # FD #10 is probably free
eval "exec ${logfd}>&0"         # duplicate stdout 

# Logs its argument
say() {
    echo "$1" >&${logfd}
}

while getopts "p:" opt; do
    case ${opt} in
        p) 
            echo "Setting port to ${OPTARG}"
            port=${OPTARG} ;;
    esac
done

setup() {
    echo "Setting up"
    rm -rf fifos
    mkdir -p fifos
    mkdir -p pids
    for pid in `ls pids`; do
        if ps ${pid} > /dev/null; then
            echo "Killing ${pid}"
            kill ${pid}
        fi
        echo "Cleaning up pidfile pids/${pid}"
        rm pids/${pid}
    done
}

mkpid() {
    mkdir -p pids
    touch pids/$1
}

rmpid() {
    rm -f pids/$1
}

handle_request() {
    local ncpid=$1
    local req_line
    read -a req_line
    say "Received ${req_line[@]}"
    send main "continue"
    # TODO use multiple variables to read instead
    local method=${req_line[0]}
    local path=${req_line[1]}
    say "method: ${method}"
    say "path: ${path}"
    say "Serving response"
    if [ "${path}" == "/" ]; then
        path="/index.html"
    fi
    case ${path} in
        /index.html | /walrus.js | /jquery-1.11.0.min.js)
            local file=`basename ${path}`
            local length=`wc -c < ${file}`
            local ext=${file##*.}
            local type=${content_types[${ext}]}

            # for whatever reason browsers don't work so well with
            # data sent piecemeal via netcat. We need to send it all
            # in one big lump. Sticking buffer(1) in front of netcat
            # worked well, but it broke SSE. So at least for now we're
            # buffering up in a tempfile.
            local body=`tempfile`
            printf "HTTP/1.1 200 OK\r\n" >> ${body}
            printf "Content-Type: ${type}\r\n" >> ${body}
            printf "Content-Length: ${length}\r\n\r\n" >> ${body}
            cat ${file} >> ${body}
            cat ${body}
            rm ${body}
            ;;
        /updates)
            handle_updates
            ;;
        /messages)
            # upcase before comparing
            case ${method^^} in
                "POST")
                    get_request_body | handle_post_message 
                    ;;
                *)
                    printf "HTTP/1.1 405 Method Not Allowed\r\nAllow: POST\r\n\r\nMethod not allowed"
                    ;;
            esac
            ;;
        /echo/*)
            printf "HTTP/1.1 200 OK\r\n\r\nHi! You requested ${method} ${path}"
            ;;

        *) 
            printf "HTTP/1.1 404 Not found\r\n\r\n Not found"
            ;;
    esac
    say "Finished handling request" 
}

get_request_body() {
    local line
    local length
    say "looking for request body"
    while read key value; do
        if [ "${key}" == "Content-Length:" ]; then
            # Must filter out CR!
            length=`echo "${value}" | sed 's/\r//'`
            say "Content-Length is ${length}"
        fi
        if [ "${key}" == `printf "\r"` ]; then
            say "found terminator"
            break
        fi
        say "discarding ${key} ${value}"
    done
    if [ -n "${length}" ]; then
        read -N "${length}" body
        say "Found body:"
        say "${body}"
        echo ${body}
    else
        say "No Content-Length found"
    fi
    say "Finished looking for request body"
}

handle_post_message() {
    say "Handling message post"
    say "Message body: $(cat)"
    say "Finished handling message post"
    printf "HTTP/1.1 201 Accepted"
}

handle_updates() {
    printf "HTTP/1.1 200 OK\r\n"
    printf "Content-Type: text/event-stream\r\n\r\n"
    for n in {00..60}; do
        sleep 1
        printf "data: This is message ${n}\n\n"
    done
}

serve_with_coproc() {
    local handler
    local nc
    local pid=$$
    coproc nc ( netcat -C -4 -v -l ${port:-${default_port}} )
    mkpid ${nc_PID}
    handle_request ${nc_PID} <&${nc[0]} >&${nc[1]}
    # close file descriptors
    eval "exec ${nc[1]}>&-"     
    eval "exec ${nc[0]}<&-"
    wait ${nc_PID}
    say "netcat process ${nc_PID} has finished"
}

agar() {
    local name=$1
    local args=${@:1}
    local fifoname=fifos/${name}
    if [ -f ${fifoname} ]; then
        rm ${fifoname}
    fi
    mkfifo ${fifoname}
    say "${name} is starting"
    self=${name} queue=${fifoname} ${name} ${args[@]} &
    local pid=$!
    mkpid ${pid}
    say "${name} has started"
}

send() {
    local dest=$1
    local message=${*:1}
    say "${dest} <- '${message}'"
    echo "${dest}" > fifos/${dest}
}

main() {
    while true; do
        say "Waiting for connection"
        serve_with_coproc &
        say "Waiting to start another server"
        read < ${queue}
    done
}

say "I am the walrus"

setup

agar main

wait
